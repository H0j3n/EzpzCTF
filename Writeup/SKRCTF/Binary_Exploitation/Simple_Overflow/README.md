# Binary Exploitation

Challenge Name : Simple Overflow

# Solution

Use the webshell and go to the directory stated in the challenge's description

![[Pasted image 20210610120336.png]]

Before we run let's analyze the source code first.

```c
#include <stdio.h>                                                                                                                                                                              
#include <stdlib.h>                                                                                                                                                                             
#include <string.h>                                                                                                                                                                             
#include <signal.h>      

#define FLAGSIZE_MAX 128

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {                                                                                                                                                                 
  fprintf(stderr, "Overflowwwww! Here's your flag: %s\n", flag);                                                                                                                                
  fflush(stderr);                                                                                                                                                                               
  exit(1);                                                                                                                                                                                      
}

void setup(){                                                                                                                                                                                   
  FILE *f = fopen("flag.txt","r");                                                                                                                                                              
  fgets(flag,FLAGSIZE_MAX,f);                                                                                                                                                                   
  signal(SIGSEGV, sigsegv_handler);                                                                                                                                                             
  gid_t gid = getegid();                                                                                                                                                                        
  setresgid(gid, gid, gid);                                                                                                                                                                     
}

int main(int argc, char **argv){                                                                                                                                                                
  setup();                                                                                                                                                                                      
  char name[16];                                                                                                                                                                                
  printf("Welcome to our first challenge!\n");                                                                                                                                                  
  printf("Please do not enter your name over 24 characters!\n");                                                                                                                                
  printf("Enter your name: ");                                                                                                                                                                  
  gets(name);                                                                                                                                                                                   
  printf("Good Bye %s\n",name);                                                                                                                                                                 
  return 0;                                                                                                                                                                                     
} 
```

From the source code we know that we need to go to `void sigsegv_handler()` to get our flag. But how can we do that? First let's identify which part is vulnerable. 

Link : [https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1049157810&id=1043284351](https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1049157810&id=1043284351)

After reading this article we know why `gets()` is vulnerable.  `gets()` has only received the name of the array which right now is `name`, it does not know how big the array is, and it is impossible to determine this from the pointer alone. When we enters input, `gets()` it will read all available data into the array, this will be fine if we enter less than `24` bytes. However, if we enter more than `24` bytes, `gets()` will not stop writing at the end of the array. Instead, it continues writing past the end and into memory it doesn't own.

You must be wonder why `24` isn't it suppose to be `16`? Actually I just know from the text that the binar give us to not put more than 24. First, let's save the code and compile it in our local machine

```bash
gcc overflow.c -o overflow -fno-stack-protector
```

You should be able to run it now. Create one file name `flag.txt` and put something inside. I prefer you install `gdb` and add with `peda` or `gef`

```bash
# GEF
https://github.com/hugsy/gef

# Peda
https://github.com/longld/peda
```

Now let's run the binary with `gdb`
```bash
gdb ./overflow
```

Use `disas main` to disammble the main function

![[Pasted image 20210610123947.png]]

Put breakpoint at the end of the function in `return`

```bash
b *0x0000555555554a70
```

![[Pasted image 20210610124015.png]]

Now let's run the program again and put `18` characters instead of `16`. You will see that it stopped in this state.

![[Pasted image 20210610124408.png]]

The most important thing we want to take a look is in this `RBP` register.

![[Pasted image 20210610124437.png]]

It holds the extra 2 character `aa` that we input. Now we want to overflow this register with more than what it suppose to have. If we look closely on what we breapoint it consists of:

```
0x0000555555554a70

00 00 55 55 55 55 4a 70

# Notes
- Consists of 8 bytes
```

So `16 + 8` will get `24` . That's why if we input characters more than `24` it will give us the flag. 

**SEGFAULT** occurs when buffer which has overflow ends at the end of the memory segment. What lies beyond the segment is, in this processor’s current state anyway, currently undefined. Thus memory accesses in this void will lead to a bus fault. No memory content is available for the processor. **It doesn’t know where to go**. So in this case the error is an immediate catastrophe.

 **Segmentation Fault** (also known as **SIGSEGV** and is usually signal 11) occur when the program tries to write/read outside the memory allocated for it or when writing memory which can only be read.In other words when the program tries to access the memory to which it doesn’t have access to. **SIGSEGV** is abbreviation for **“Segmentation Violation”. **

Let's try run again with `25` characters. 

![[Pasted image 20210610125542.png]]

You can see that it holds the value of our extra characters

![[Pasted image 20210610125610.png]]

If we enter `c` it will continue and give us **SIGSEGV** which mean it will enter the function that has our flag!

![[Pasted image 20210610125956.png]]

# Flag

![[Pasted image 20210610130038.png]]



